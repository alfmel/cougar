<?php

namespace Cougar\UnitTests\Model;

use PDO;
use Cougar\Model\PdoModel;
use Cougar\Security\Security;
use Cougar\Util\QueryParameter;

/**
 * Generated by PHPUnit_SkeletonGenerator 1.2.0 on 2013-01-23 at 12:28:52.
 */
class PdoModelTest extends \PHPUnit_Framework_TestCase {

    public static function setUpBeforeClass()
    {
        require_once(__DIR__ . "/../../cougar.php");
    }

    /**
     * Set the properties on the object; mimics the behavior of PDOStatement
     * when fetching directly into the object
     */
    public static function setProperties()
    {
        $object = self::$pdoFetchIntoObject;

        $object->userId = "12345";
        $object->lastName = "Doe";
        $object->firstName = "John";
        $object->emailAddress = "john.doe@example.com";
        $object->phone = "800-555-1212";
        $object->birthDate = "01 JUN 1960";
        $object->active = "1";
        $object->attributes = json_encode(array("a" => 1, "b" => 2));
    }

    /**
     * @var \Cougar\UnitTests\Model\PdoModelUnitTest
     */
    public static $pdoFetchIntoObject;

    /**
     * @covers \Cougar\Model\PdoModel::__construct
     * @covers \Cougar\Model\PdoModel::getRecord
     * @covers \Cougar\Model\PdoModel::getCacheKey
     */
    public function testLoad() {
        $object = null;

        $security = new Security();
        
        $cache = $this->getMock("\\Cougar\\Cache\\Cache");
        $cache->expects($this->once())
            ->method("get")
            ->with("unittest.model.12345")
            ->will($this->returnValue(false));
        $cache->expects($this->once())
            ->method("set")
            ->will($this->returnValue(false));
        
        $pdo_statement = $this->getMockBuilder("\\PDOStatement")
            ->disableArgumentCloning()
            ->getMock();
        $pdo_statement->expects($this->at(0))
            ->method("setFetchMode")
            ->will($this->returnCallback(function($type, $object)
                { PdoModelTest::$pdoFetchIntoObject = $object; }));
        $pdo_statement->expects($this->at(1))
            ->method("execute")
            ->with($this->equalTo(array("userId" => 12345)))
            ->will($this->returnValue(true));
        $pdo_statement->expects($this->at(2))
            ->method("fetch")
            ->will($this->returnCallback(function()
                { PdoModelTest::setProperties(); }));
        $pdo_statement->expects($this->at(3))
            ->method("fetch")
            ->will($this->returnValue(false));
        
        $pdo = $this->getMock("\\PDO",
            array("prepare"),
            array("sqlite::memory:"));
        $pdo->expects($this->once())
            ->method("prepare")
            ->with($this->equalTo(
                "SELECT userId, lastName, firstName, emailAddress AS email, " .
                    "phone, birthDate, active, attributes " .
                "FROM user WHERE userId = :userId"))
            ->will($this->returnValue($pdo_statement));
        
        $object = new PdoModelUnitTest($security, $cache, $pdo,
            array("userId" => 12345));
        $this->assertEquals(12345, $object->userId);
        $this->assertEquals("Doe", $object->lastName);
        $this->assertEquals("John", $object->firstName);
        $this->assertEquals("john.doe@example.com", $object->email);
        $this->assertEquals("800-555-1212", $object->phone);
        $this->assertInstanceOf("\\Cougar\\Util\\DateTime", $object->birthDate);
        $this->assertEquals("1960-06-01", (string) $object->birthDate);
        $this->assertTrue($object->active);
        $this->assertEquals(array("a" => 1, "b" => 2), $object->attributes);
    }

    /**
     * @covers \Cougar\Model\PdoModel::__construct
     * @covers \Cougar\Model\PdoModel::getRecord
     * @covers \Cougar\Model\PdoModel::getCacheKey
     * @expectedException \Cougar\Exceptions\RecordNotFoundException
     */
    public function testLoadRecordNotFound() {
        $security = new Security();
        
        $cache = $this->getMock("\\Cougar\\Cache\\Cache");
        $cache->expects($this->once())
            ->method("get")
            ->with("unittest.model.12345")
            ->will($this->returnValue(false));
        
        $pdo_statement = $this->getMock("\\PDOStatement");
        $pdo_statement->expects($this->once())
            ->method("execute")
            ->with($this->equalTo(array("userId" => 12345)))
            ->will($this->returnValue(true));
        $pdo_statement->expects($this->once())
            ->method("fetch")
            ->will($this->returnValue(false));
        
        $pdo = $this->getMock("\\PDO",
            array("prepare"),
            array("sqlite::memory:"));
        $pdo->expects($this->once())
            ->method("prepare")
            ->with($this->equalTo(
                "SELECT userId, lastName, firstName, emailAddress AS email, " .
                    "phone, birthDate, active, attributes " .
                "FROM user WHERE userId = :userId"))
            ->will($this->returnValue($pdo_statement));
        
        $object = new PdoModelUnitTest($security, $cache, $pdo,
            array("userId" => "12345"));
    }

    /**
     * @covers \Cougar\Model\PdoModel::__construct
     * @covers \Cougar\Model\PdoModel::__get
     * @covers \Cougar\Model\PdoModel::__set
     * @covers \Cougar\Model\PdoModel::save
     * @covers \Cougar\Model\PdoModel::getCacheKey
     */
    public function testSaveInsert() {        
        $security = new Security();
        
        $cache = $this->getMock("\\Cougar\\Cache\\Cache");
        $cache->expects($this->never())
            ->method("get");
        $cache->expects($this->once())
            ->method("set")
            ->will($this->returnValue(false));
        
        $pdo_statement = $this->getMock("\\PDOStatement");
        $pdo_statement->expects($this->once())
            ->method("execute")
            ->with($this->equalTo(array(
                "userId" => null,
                "lastName" => "Doe",
                "firstName" => "John",
                "email" => "john.doe@example.com",
                "phone" => "800-555-1212",
                "birthDate" => "1960-06-01",
                "active" => true,
                "attributes" => json_encode(array("a" => 1, "b" => 2)))))
            ->will($this->returnValue(true));
        $pdo_statement->expects($this->once())
            ->method("rowCount")
            ->will($this->returnValue(1));

        $pdo = $this->getMock("\\PDO",
            array("prepare"),
            array("sqlite::memory:"));
        $pdo->expects($this->once())
            ->method("prepare")
            ->with($this->equalTo(
                "INSERT INTO user " .
                "(userId, lastName, firstName, emailAddress, phone, " .
                    "birthDate, active, attributes) " .
                "VALUES(:userId, :lastName, :firstName, :email, :phone, " .
                    ":birthDate, :active, :attributes)"))
            ->will($this->returnValue($pdo_statement));
        
        # Test set
        $object = new PdoModelUnitTest($security, $cache, $pdo);
        $object->firstName = "John";
        $object->lastName = "Doe";
        $object->email = "john.doe@example.com";
        $object->phone = "800-555-1212";
        $object->birthDate = "01 JUN 1960";
        $object->attributes = array("a" => 1, "b" => 2);
    
        # Test save with insert
        $object->save();
        
        # Test the properties after save
        $this->assertEquals("John", $object->firstName);
        $this->assertEquals("Doe", $object->lastName);
        $this->assertEquals("john.doe@example.com", $object->email);
        $this->assertEquals("800-555-1212", $object->phone);
        $this->assertInstanceOf("\\Cougar\\Util\\DateTime", $object->birthDate);
        $this->assertEquals("1960-06-01", (string) $object->birthDate);
        $this->assertTrue($object->active);
        $this->assertEquals(array("a" => 1, "b" => 2), $object->attributes);
        
        # Test getting the changed values
        $changes = $object->lastChanges();
        $this->assertArrayHasKey("firstName", $changes);
        $this->assertArrayHasKey("lastName", $changes);
        $this->assertArrayHasKey("email", $changes);
        $this->assertArrayHasKey("phone", $changes);
        $this->assertArrayHasKey("birthDate", $changes);
        $this->assertArrayHasKey("attributes", $changes);
        
        $this->assertNull($changes["firstName"]);
        $this->assertNull($changes["lastName"]);
        $this->assertNull($changes["email"]);
        $this->assertNull($changes["phone"]);
        $this->assertNull($changes["birthDate"]);
        $this->assertNull($changes["attributes"]);
    }

    /**
     * @covers \Cougar\Model\PdoModel::__construct
     * @covers \Cougar\Model\PdoModel::__get
     * @covers \Cougar\Model\PdoModel::__set
     * @covers \Cougar\Model\PdoModel::save
     * @covers \Cougar\Model\PdoModel::getCacheKey
     */
    public function testSaveInsertNullDate() {
        $security = new Security();

        $cache = $this->getMock("\\Cougar\\Cache\\Cache");
        $cache->expects($this->never())
            ->method("get");
        $cache->expects($this->once())
            ->method("set")
            ->will($this->returnValue(false));

        $pdo_statement = $this->getMock("\\PDOStatement");
        $pdo_statement->expects($this->once())
            ->method("execute")
            ->with($this->equalTo(array(
                "userId" => null,
                "lastName" => "Doe",
                "firstName" => "John",
                "email" => "john.doe@example.com",
                "phone" => "800-555-1212",
                "birthDate" => null,
                "active" => true,
                "attributes" => json_encode(array("a" => 1, "b" => 2)))))
            ->will($this->returnValue(true));
        $pdo_statement->expects($this->once())
            ->method("rowCount")
            ->will($this->returnValue(1));

        $pdo = $this->getMock("\\PDO",
            array("prepare"),
            array("sqlite::memory:"));
        $pdo->expects($this->once())
            ->method("prepare")
            ->with($this->equalTo(
                "INSERT INTO user " .
                "(userId, lastName, firstName, emailAddress, phone, " .
                "birthDate, active, attributes) " .
                "VALUES(:userId, :lastName, :firstName, :email, :phone, " .
                ":birthDate, :active, :attributes)"))
            ->will($this->returnValue($pdo_statement));

        # Test set
        $object = new PdoModelUnitTest($security, $cache, $pdo);
        $object->firstName = "John";
        $object->lastName = "Doe";
        $object->email = "john.doe@example.com";
        $object->phone = "800-555-1212";
        $object->birthDate = null;
        $object->attributes = array("a" => 1, "b" => 2);

        # Test save with insert
        $object->save();

        # Test the properties after save
        $this->assertEquals("John", $object->firstName);
        $this->assertEquals("Doe", $object->lastName);
        $this->assertEquals("john.doe@example.com", $object->email);
        $this->assertEquals("800-555-1212", $object->phone);
        $this->assertNull($object->birthDate);
        $this->assertTrue($object->active);
        $this->assertEquals(array("a" => 1, "b" => 2), $object->attributes);

        # Test getting the changed values
        $changes = $object->lastChanges();
        $this->assertArrayHasKey("firstName", $changes);
        $this->assertArrayHasKey("lastName", $changes);
        $this->assertArrayHasKey("email", $changes);
        $this->assertArrayHasKey("phone", $changes);
        $this->assertArrayHasKey("attributes", $changes);

        $this->assertNull($changes["firstName"]);
        $this->assertNull($changes["lastName"]);
        $this->assertNull($changes["email"]);
        $this->assertNull($changes["phone"]);
        $this->assertNull($changes["attributes"]);
    }

    /**
     * @covers \Cougar\Model\PdoModel::__construct
     * @covers \Cougar\Model\PdoModel::__get
     * @covers \Cougar\Model\PdoModel::__set
     * @covers \Cougar\Model\PdoModel::save
     * @covers \Cougar\Model\PdoModel::getCacheKey
     */
    public function testSaveInsertFromLoad() {        
        $security = new Security();
        
        $cache = $this->getMock("\\Cougar\\Cache\\Cache");
        $cache->expects($this->never())
            ->method("get");
        $cache->expects($this->once())
            ->method("set")
            ->will($this->returnValue(false));
        
        $pdo_statement = $this->getMock("\\PDOStatement");
        $pdo_statement->expects($this->once())
            ->method("execute")
            ->with($this->equalTo(array(
                "userId" => null,
                "lastName" => "Doe",
                "firstName" => "John",
                "email" => "john.doe@example.com",
                "phone" => "800-555-1212",
                "birthDate" => "1960-06-01",
                "active" => true,
                "attributes" => json_encode(array("a" => 1, "b" => 2)))))
            ->will($this->returnValue(true));
        $pdo_statement->expects($this->once())
            ->method("rowCount")
            ->will($this->returnValue(1));

        $pdo = $this->getMock("\\PDO",
            array("prepare"),
            array("sqlite::memory:"));
        $pdo->expects($this->once())
            ->method("prepare")
            ->with($this->equalTo(
                "INSERT INTO user " .
                "(userId, lastName, firstName, emailAddress, phone, " .
                    "birthDate, active, attributes) " .
                "VALUES(:userId, :lastName, :firstName, :email, :phone, " .
                    ":birthDate, :active, :attributes)"))
            ->will($this->returnValue($pdo_statement));
        
        # Test set
        $object = new PdoModelUnitTest($security, $cache, $pdo,
            array("userId" => "",
                "firstName" => "John",
                "lastName" => "Doe",
                "email" => "john.doe@example.com",
                "phone" => "800-555-1212",
                "birthDate" => "01 JUN 1960",
                // We don't set active to make sure default value is set
                "attributes" => array("a" => 1, "b" => 2)));
    
        # Test save with insert
        $object->save();
        
        # Test get
        $this->assertEquals("John", $object->firstName);
        $this->assertEquals("Doe", $object->lastName);
        $this->assertEquals("john.doe@example.com", $object->email);
        $this->assertEquals("800-555-1212", $object->phone);
        $this->assertInstanceOf("\\Cougar\\Util\\DateTime", $object->birthDate);
        $this->assertEquals("1960-06-01", (string) $object->birthDate);
        
        # Test getting the changed values
        $changes = $object->lastChanges();
        $this->assertArrayHasKey("firstName", $changes);
        $this->assertArrayHasKey("lastName", $changes);
        $this->assertArrayHasKey("email", $changes);
        $this->assertArrayHasKey("phone", $changes);
        $this->assertArrayHasKey("birthDate", $changes);
        
        $this->assertNull($changes["firstName"]);
        $this->assertNull($changes["lastName"]);
        $this->assertNull($changes["email"]);
        $this->assertNull($changes["phone"]);
        $this->assertNull($changes["birthDate"]);
    }

    /**
     * @covers \Cougar\Model\PdoModel::__construct
     * @covers \Cougar\Model\PdoModel::getRecord
     * @covers \Cougar\Model\PdoModel::buildWhereClause
     * @covers \Cougar\Model\PdoModel::getWhereParameters
     * @covers \Cougar\Model\PdoModel::getCacheKey
     * @covers \Cougar\Model\PdoModel::save
     */
    public function testSaveUpdate() {
        $security = new Security();
        
        $cache = $this->getMock("\\Cougar\\Cache\\Cache");
        $cache->expects($this->once())
            ->method("get")
            ->with("unittest.model.12345")
            ->will($this->returnValue(false));
        $cache->expects($this->exactly(2))
            ->method("set")
            ->will($this->returnValue(false));
        
        $pdo_statement_select = $this->getMockBuilder("\\PDOStatement")
            ->disableArgumentCloning()
            ->getMock();
        $pdo_statement_select->expects($this->at(0))
            ->method("setFetchMode")
            ->will($this->returnCallback(function($type, $object)
                { PdoModelTest::$pdoFetchIntoObject = $object; }));
        $pdo_statement_select->expects($this->at(1))
            ->method("execute")
            ->with($this->equalTo(array("userId" => 12345)))
            ->will($this->returnValue(true));
        $pdo_statement_select->expects($this->at(2))
            ->method("fetch")
            ->will($this->returnCallback(function()
                { PdoModelTest::setProperties(); }));
        $pdo_statement_select->expects($this->at(3))
            ->method("fetch")
            ->will($this->returnValue(false));
        
        $pdo_statement_update = $this->getMock("\\PDOStatement");
        $pdo_statement_update->expects($this->once())
            ->method("execute")
            ->with($this->equalTo(array(
                "lastName" => "Jones",
                "firstName" => "Mary",
                "email" => "mary.jones@example.com",
                "birthDate" => "1961-08-01",
                "attributes" => json_encode(array("a" => 3, "b" => 4)),
                "userId" => 12345)))
            ->will($this->returnValue(true));
        $pdo_statement_update->expects($this->once())
            ->method("rowCount")
            ->will($this->returnValue(1));

        $pdo = $this->getMock("\\PDO",
            array("prepare"),
            array("sqlite::memory:"));
        $pdo->expects($this->at(0))
            ->method("prepare")
            ->with($this->equalTo(
                "SELECT userId, lastName, firstName, emailAddress AS email, " .
                    "phone, birthDate, active, attributes " .
                "FROM user WHERE userId = :userId"))
            ->will($this->returnValue($pdo_statement_select));
        $pdo->expects($this->at(1))
            ->method("prepare")
            ->with($this->equalTo(
                "UPDATE user " .
                "SET lastName = :lastName, " .
                    "firstName = :firstName, " .
                    "emailAddress = :email, " .
                    "birthDate = :birthDate, " .
                    "attributes = :attributes " .
                "WHERE userId = :userId"))
            ->will($this->returnValue($pdo_statement_update));
        
        $object = new PdoModelUnitTest($security, $cache, $pdo,
            array("userId" => "12345"));
        $object->firstName = "Mary";
        $object->lastName = "Jones";
        $object->email = "mary.jones@example.com";
        $object->birthDate = "01 AUG 1961";
        $object->attributes = array("a" => 3, "b" => 4);
        $object->save();
        
        # Test getting the changed values
        $changes = $object->lastChanges();
        $this->assertCount(5, $changes);
        $this->assertArrayHasKey("firstName", $changes);
        $this->assertArrayHasKey("lastName", $changes);
        $this->assertArrayHasKey("email", $changes);
        $this->assertArrayHasKey("birthDate", $changes);
        
        $this->assertEquals("John", $changes["firstName"]);
        $this->assertEquals("Doe", $changes["lastName"]);
        $this->assertEquals("john.doe@example.com", $changes["email"]);
        $this->assertEquals("1960-06-01", (string) $changes["birthDate"]);
        $this->assertEquals(array("a" => 1, "b" => 2), $changes["attributes"]);
    }

    /**
     * @covers \Cougar\Model\PdoModel::__construct
     * @covers \Cougar\Model\PdoModel::getRecord
     * @covers \Cougar\Model\PdoModel::buildWhereClause
     * @covers \Cougar\Model\PdoModel::getWhereParameters
     * @covers \Cougar\Model\PdoModel::getCacheKey
     * @covers \Cougar\Model\PdoModel::save
     */
    public function testSaveUpdateNullDate() {
        $security = new Security();

        $cache = $this->getMock("\\Cougar\\Cache\\Cache");
        $cache->expects($this->once())
            ->method("get")
            ->with("unittest.model.12345")
            ->will($this->returnValue(false));
        $cache->expects($this->exactly(2))
            ->method("set")
            ->will($this->returnValue(false));

        $pdo_statement_select = $this->getMockBuilder("\\PDOStatement")
            ->disableArgumentCloning()
            ->getMock();
        $pdo_statement_select->expects($this->at(0))
            ->method("setFetchMode")
            ->will($this->returnCallback(function($type, $object)
            { PdoModelTest::$pdoFetchIntoObject = $object; }));
        $pdo_statement_select->expects($this->at(1))
            ->method("execute")
            ->with($this->equalTo(array("userId" => 12345)))
            ->will($this->returnValue(true));
        $pdo_statement_select->expects($this->at(2))
            ->method("fetch")
            ->will($this->returnCallback(function()
            { PdoModelTest::setProperties(); }));
        $pdo_statement_select->expects($this->at(3))
            ->method("fetch")
            ->will($this->returnValue(false));

        $pdo_statement_update = $this->getMock("\\PDOStatement");
        $pdo_statement_update->expects($this->once())
            ->method("execute")
            ->with($this->equalTo(array(
                "lastName" => "Jones",
                "firstName" => "Mary",
                "email" => "mary.jones@example.com",
                "birthDate" => null,
                "attributes" => json_encode(array("a" => 3, "b" => 4)),
                "userId" => 12345)))
            ->will($this->returnValue(true));
        $pdo_statement_update->expects($this->once())
            ->method("rowCount")
            ->will($this->returnValue(1));

        $pdo = $this->getMock("\\PDO",
            array("prepare"),
            array("sqlite::memory:"));
        $pdo->expects($this->at(0))
            ->method("prepare")
            ->with($this->equalTo(
                "SELECT userId, lastName, firstName, emailAddress AS email, " .
                "phone, birthDate, active, attributes " .
                "FROM user WHERE userId = :userId"))
            ->will($this->returnValue($pdo_statement_select));
        $pdo->expects($this->at(1))
            ->method("prepare")
            ->with($this->equalTo(
                "UPDATE user " .
                "SET lastName = :lastName, " .
                "firstName = :firstName, " .
                "emailAddress = :email, " .
                "birthDate = :birthDate, " .
                "attributes = :attributes " .
                "WHERE userId = :userId"))
            ->will($this->returnValue($pdo_statement_update));

        $object = new PdoModelUnitTest($security, $cache, $pdo,
            array("userId" => "12345"));
        $object->firstName = "Mary";
        $object->lastName = "Jones";
        $object->email = "mary.jones@example.com";
        $object->birthDate = null;
        $object->attributes = array("a" => 3, "b" => 4);
        $object->save();

        # Test getting the changed values
        $changes = $object->lastChanges();
        $this->assertCount(5, $changes);
        $this->assertArrayHasKey("firstName", $changes);
        $this->assertArrayHasKey("lastName", $changes);
        $this->assertArrayHasKey("email", $changes);
        $this->assertArrayHasKey("birthDate", $changes);

        $this->assertEquals("John", $changes["firstName"]);
        $this->assertEquals("Doe", $changes["lastName"]);
        $this->assertEquals("john.doe@example.com", $changes["email"]);
        $this->assertEquals("1960-06-01", (string) $changes["birthDate"]);
        $this->assertEquals(array("a" => 1, "b" => 2), $changes["attributes"]);
    }

    /**
     * @covers \Cougar\Model\PdoModel::__construct
     * @covers \Cougar\Model\PdoModel::getRecord
     * @covers \Cougar\Model\PdoModel::buildWhereClause
     * @covers \Cougar\Model\PdoModel::getWhereParameters
     * @covers \Cougar\Model\PdoModel::getCacheKey
     * @covers \Cougar\Model\PdoModel::save
     */
    public function testSaveUpdateOnLoad() {
        $security = new Security();
        
        $cache = $this->getMock("\\Cougar\\Cache\\Cache");
        $cache->expects($this->once())
            ->method("get")
            ->with("unittest.model.12345")
            ->will($this->returnValue(false));
        $cache->expects($this->exactly(2))
            ->method("set")
            ->will($this->returnValue(false));

        $pdo_statement_select = $this->getMockBuilder("\\PDOStatement")
            ->disableArgumentCloning()
            ->getMock();
        $pdo_statement_select->expects($this->at(0))
            ->method("setFetchMode")
            ->will($this->returnCallback(function($type, $object)
            { PdoModelTest::$pdoFetchIntoObject = $object; }));
        $pdo_statement_select->expects($this->at(1))
            ->method("execute")
            ->with($this->equalTo(array("userId" => 12345)))
            ->will($this->returnValue(true));
        $pdo_statement_select->expects($this->at(2))
            ->method("fetch")
            ->will($this->returnCallback(function()
            { PdoModelTest::setProperties(); }));
        $pdo_statement_select->expects($this->at(3))
            ->method("fetch")
            ->will($this->returnValue(false));
        
        $pdo_statement_update = $this->getMock("\\PDOStatement");
        $pdo_statement_update->expects($this->once())
            ->method("execute")
            ->with($this->equalTo(array(
                "lastName" => "Jones",
                "firstName" => "Mary",
                "email" => "mary.jones@example.com",
                "attributes" => json_encode(array("a" => 3, "b" => 4)),
                "userId" => 12345)))
            ->will($this->returnValue(true));
        $pdo_statement_update->expects($this->once())
            ->method("rowCount")
            ->will($this->returnValue(1));

        $pdo = $this->getMock("\\PDO",
            array("prepare"),
            array("sqlite::memory:"));
        $pdo->expects($this->at(0))
            ->method("prepare")
            ->with($this->equalTo(
                "SELECT userId, lastName, firstName, emailAddress AS email, " .
                    "phone, birthDate, active, attributes " .
                "FROM user WHERE userId = :userId"))
            ->will($this->returnValue($pdo_statement_select));
        $pdo->expects($this->at(1))
            ->method("prepare")
            ->with($this->equalTo(
                "UPDATE user " .
                "SET lastName = :lastName, " .
                    "firstName = :firstName, " .
                    "emailAddress = :email, " .
                    "attributes = :attributes " .
                "WHERE userId = :userId"))
            ->will($this->returnValue($pdo_statement_update));
        
        $object = new PdoModelUnitTest($security, $cache, $pdo,
            array("userId" => "12345",
                "lastName" => "Jones",
                "firstName" => "Mary",
                "email" => "mary.jones@example.com",
                "attributes" => array("a" => 3, "b" => 4)));
        $object->save();
        
        # Test getting the changed values
        $changes = $object->lastChanges();
        $this->assertCount(4, $changes);
        $this->assertArrayHasKey("firstName", $changes);
        $this->assertArrayHasKey("lastName", $changes);
        $this->assertArrayHasKey("email", $changes);
        $this->assertArrayHasKey("attributes", $changes);
        
        $this->assertEquals("John", $changes["firstName"]);
        $this->assertEquals("Doe", $changes["lastName"]);
        $this->assertEquals("john.doe@example.com", $changes["email"]);
        $this->assertEquals(array("a" => 1, "b" => 2), $changes["attributes"]);
    }

    /**
     * @covers \Cougar\Model\PdoModel::__construct
     * @covers \Cougar\Model\PdoModel::getRecord
     * @covers \Cougar\Model\PdoModel::buildWhereClause
     * @covers \Cougar\Model\PdoModel::getWhereParameters
     * @covers \Cougar\Model\PdoModel::getCacheKey
     * @covers \Cougar\Model\PdoModel::save
     * @expectedException \Cougar\Exceptions\Exception
     */
    public function testUpdateReadOnlyProperty() {
        $security = new Security();
        
        $cache = $this->getMock("\\Cougar\\Cache\\Cache");
        $cache->expects($this->once())
            ->method("get")
            ->with("unittest.model.12345")
            ->will($this->returnValue(false));

        $pdo_statement_select = $this->getMockBuilder("\\PDOStatement")
            ->disableArgumentCloning()
            ->getMock();
        $pdo_statement_select->expects($this->at(0))
            ->method("setFetchMode")
            ->will($this->returnCallback(function($type, $object)
            { PdoModelTest::$pdoFetchIntoObject = $object; }));
        $pdo_statement_select->expects($this->at(1))
            ->method("execute")
            ->with($this->equalTo(array("userId" => 12345)))
            ->will($this->returnValue(true));
        $pdo_statement_select->expects($this->at(2))
            ->method("fetch")
            ->will($this->returnCallback(function()
            { PdoModelTest::setProperties(); }));
        $pdo_statement_select->expects($this->at(3))
            ->method("fetch")
            ->will($this->returnValue(false));
        
        $pdo = $this->getMock("\\PDO",
            array("prepare"),
            array("sqlite::memory:"));
        $pdo->expects($this->at(0))
            ->method("prepare")
            ->with($this->equalTo(
                "SELECT userId, lastName, firstName, emailAddress AS email, " .
                    "phone, birthDate, active, attributes " .
                "FROM user WHERE userId = :userId"))
            ->will($this->returnValue($pdo_statement_select));
        
        $object = new PdoModelUnitTest($security, $cache, $pdo,
            array("userId" => "12345"));
        $object->userId = "54321";
        $object->save();
    }

    /**
     * @covers \Cougar\Model\PdoModel::__construct
     * @covers \Cougar\Model\PdoModel::getRecord
     * @covers \Cougar\Model\PdoModel::buildWhereClause
     * @covers \Cougar\Model\PdoModel::getWhereParameters
     * @covers \Cougar\Model\PdoModel::getCacheKey
     * @covers \Cougar\Model\PdoModel::delete
     */
    public function testDelete() {
        $security = new Security();
        
        $cache = $this->getMock("\\Cougar\\Cache\\Cache");
        $cache->expects($this->once())
            ->method("get")
            ->with("unittest.model.12345")
            ->will($this->returnValue(false));
        $cache->expects($this->once())
            ->method("clear")
            ->will($this->returnValue(false));

        $pdo_statement_select = $this->getMockBuilder("\\PDOStatement")
            ->disableArgumentCloning()
            ->getMock();
        $pdo_statement_select->expects($this->at(0))
            ->method("setFetchMode")
            ->will($this->returnCallback(function($type, $object)
            { PdoModelTest::$pdoFetchIntoObject = $object; }));
        $pdo_statement_select->expects($this->at(1))
            ->method("execute")
            ->with($this->equalTo(array("userId" => 12345)))
            ->will($this->returnValue(true));
        $pdo_statement_select->expects($this->at(2))
            ->method("fetch")
            ->will($this->returnCallback(function()
            { PdoModelTest::setProperties(); }));
        $pdo_statement_select->expects($this->at(3))
            ->method("fetch")
            ->will($this->returnValue(false));
        
        $pdo_statement_delete = $this->getMock("\\PDOStatement");
        $pdo_statement_delete->expects($this->once())
            ->method("execute")
            ->with($this->equalTo(array("userId" => 12345)))
            ->will($this->returnValue(true));
        $pdo_statement_delete->expects($this->exactly(2))
            ->method("rowCount")
            ->will($this->returnValue(1));

        $pdo = $this->getMock("\\PDO",
            array("prepare"),
            array("sqlite::memory:"));
        $pdo->expects($this->at(0))
            ->method("prepare")
            ->with($this->equalTo(
                "SELECT userId, lastName, firstName, emailAddress AS email, " .
                    "phone, birthDate, active, attributes " .
                "FROM user WHERE userId = :userId"))
            ->will($this->returnValue($pdo_statement_select));
        $pdo->expects($this->at(1))
            ->method("prepare")
            ->with($this->equalTo(
                "DELETE FROM user " .
                "WHERE userId = :userId"))
            ->will($this->returnValue($pdo_statement_delete));
        
        $object = new PdoModelUnitTest($security, $cache, $pdo,
            array("userId" => "12345"));
        $object->delete();
    }
    
    /**
     * @covers \Cougar\Model\PdoModel::__construct
     * @covers \Cougar\Model\PdoModel::getRecord
     * @covers \Cougar\Model\PdoModel::current
     * @covers \Cougar\Model\PdoModel::key
     * @covers \Cougar\Model\PdoModel::next
     * @covers \Cougar\Model\PdoModel::rewind
     * @covers \Cougar\Model\PdoModel::valid
     */
    public function testIteratorMethods() {
        $security = new Security();
        
        $cache = $this->getMock("\\Cougar\\Cache\\Cache");
        
        $pdo = new PDO("sqlite::memory:");
        
        $object = new PdoModelUnitTest($security, $cache, $pdo);
        $object->userId = "userId value";
        $object->lastName = "lastName value";
        $object->firstName = "firstName value";
        $object->email = "email@somewhere.com";
        $object->phone = "phone value";
        $object->active = true;
        $object->attributes = array("a" => 1, "b" => 2);
        
        $array = array();
        foreach($object as $key => $value)
        {
            $array[$key] = $value;
        }
        $this->assertEquals($object->__toArray(), $array);
    }
    
    /**
     * @covers \Cougar\Model\PdoModel::__construct
     * @covers \Cougar\Model\PdoModel::query
     * 
     * @todo Until the cache supports grouped clearing, caching of queries has
     *       been disabled. Change the cache entries as necessary once it works.
     */
    public function testQuery() {
        $parameters = array(
            new QueryParameter("firstName", "John", "**"),
            new QueryParameter("lastName", "Doe", "**")
        );
        
        $security = new Security();
        /*
        $cache = $this->getMock("\\Cougar\\Cache\\Cache");
        $cache->expects($this->once())
            ->method("get")
            ->with("unittest.model.query." .
                md5(serialize($parameters) . "array.__default__"))
            ->will($this->returnValue(false));
        $cache->expects($this->once())
            ->method("set")
            ->will($this->returnValue(false));
        */
        $cache = $this->getMock("\\Cougar\\Cache\\Cache");
        $cache->expects($this->never())
            ->method("get");
        $cache->expects($this->never())
            ->method("set");
        
        $pdo_statement = $this->getMock("\\PDOStatement");
        $pdo_statement->expects($this->once())
            ->method("execute")
            ->with($this->equalTo(array(
                "firstName" => "%John%",
                "lastName" => "%Doe%")))
            ->will($this->returnValue(true));
        $pdo_statement->expects($this->at(1))
            ->method("fetchAll")
            ->will($this->returnValue(array(array(
                "userId" => "12345",
                "lastName" => "Doe",
                "firstName" => "John",
                "emailAddress" => "john.doe@example.com",
                "phone" => "800-555-1212",
                "active" => "1",
                "attributes" => json_encode(array("a" =>1, "b" => 2))))));
        
        $pdo = $this->getMock("\\PDO",
            array("prepare"),
            array("sqlite::memory:"));
        $pdo->expects($this->once())
            ->method("prepare")
            ->with($this->equalTo(
                "SELECT userId, lastName, firstName, emailAddress AS email, " .
                    "phone, birthDate, active, attributes " .
                "FROM user  WHERE firstName LIKE :firstName AND " .
                    "lastName LIKE :lastName " .
                "LIMIT 10000 OFFSET 0"))
            ->will($this->returnValue($pdo_statement));
        
        $object = new PdoModelUnitTest($security, $cache, $pdo);
        $query_result = $object->query($parameters);
        $this->assertCount(1, $query_result);
        $this->assertArrayHasKey("userId", $query_result[0]);
        $this->assertEquals("12345", $query_result[0]["userId"]);
    }

    /**
     * @covers \Cougar\Model\PdoModel::__construct
     * @covers \Cougar\Model\PdoModel::query
     *
     * @todo Until the cache supports grouped clearing, caching of queries has
     *       been disabled. Change the cache entries as necessary once it works.
     */
    public function testQueryOciRenameKeys() {
        // This test only works if we have the OCI driver installed
        if (! in_array("oci", PDO::getAvailableDrivers()))
        {
            $this->markTestSkipped("OCI driver is required to run this test");
        }

        $security = new Security();
        /*
        $cache = $this->getMock("\\Cougar\\Cache\\Cache");
        $cache->expects($this->once())
            ->method("get")
            ->with("unittest.model.query." .
                md5(serialize($parameters) . "array.__default__"))
            ->will($this->returnValue(false));
        $cache->expects($this->once())
            ->method("set")
            ->will($this->returnValue(false));
        */
        $cache = $this->getMock("\\Cougar\\Cache\\Cache");
        $cache->expects($this->never())
            ->method("get");
        $cache->expects($this->never())
            ->method("set");

        $pdo_statement = $this->getMock("\\PDOStatement");
        $pdo_statement->expects($this->once())
            ->method("execute")
            ->with()
            ->will($this->returnValue(true));
        $pdo_statement->expects($this->at(1))
            ->method("fetchAll")
            ->will($this->returnValue(array(array(
                "USERID" => "12345",
                "LASTNAME" => "Doe",
                "FIRSTNAME" => "John",
                "EMAIL" => "john.doe@example.com",
                "PHONE" => "800-555-1212",
                "ACTIVE" => "1",
                "ATTRIBUTES" => json_encode(array("a" =>1, "b" => 2))))));

        $pdo = $this->getMock("\\PDO",
            array("prepare"),
            array("oci:"));
        $pdo->expects($this->once())
            ->method("prepare")
            ->with($this->equalTo(
                "SELECT userId, lastName, firstName, emailAddress AS email, " .
                "phone, birthDate, active, attributes " .
                "FROM user  " .
                "LIMIT 10000 OFFSET 0"))
            ->will($this->returnValue($pdo_statement));

        $object = new PdoModelUnitTest($security, $cache, $pdo);
        $query_result = $object->query();
        $this->assertCount(1, $query_result);
        $this->assertArrayHasKey("userId", $query_result[0]);
        $this->assertEquals("12345", $query_result[0]["userId"]);
        $this->assertArrayHasKey("lastName", $query_result[0]);
        $this->assertArrayHasKey("firstName", $query_result[0]);
        $this->assertArrayHasKey("email", $query_result[0]);
        $this->assertArrayHasKey("phone", $query_result[0]);
        $this->assertArrayHasKey("active", $query_result[0]);
        $this->assertArrayHasKey("attributes", $query_result[0]);
    }

    /**
     * @covers \Cougar\Model\PdoModel::__construct
     * @covers \Cougar\Model\PdoModel::query
     *
     * @todo Until the cache supports grouped clearing, caching of queries has
     *       been disabled. Change the cache entries as necessary once it works.
     */
    public function testQueryWithLimit() {
        $parameters = array(
            new QueryParameter("firstName", "John", "**"),
            new QueryParameter("lastName", "Doe", "**"),
            new QueryParameter("_limit", "100")
        );

        $security = new Security();

        $cache = $this->getMock("\\Cougar\\Cache\\Cache");
        $cache->expects($this->never())
            ->method("get");
        $cache->expects($this->never())
            ->method("set");

        $pdo_statement = $this->getMock("\\PDOStatement");
        $pdo_statement->expects($this->once())
            ->method("execute")
            ->with($this->equalTo(array(
                "firstName" => "%John%",
                "lastName" => "%Doe%")))
            ->will($this->returnValue(true));
        $pdo_statement->expects($this->at(1))
            ->method("fetchAll")
            ->will($this->returnValue(array(array(
                "userId" => "12345",
                "lastName" => "Doe",
                "firstName" => "John",
                "emailAddress" => "john.doe@example.com",
                "phone" => "800-555-1212",
                "active" => "1",
                "attributes" => json_encode(array("a" =>1, "b" => 2))))));

        $pdo = $this->getMock("\\PDO",
            array("prepare"),
            array("sqlite::memory:"));
        $pdo->expects($this->once())
            ->method("prepare")
            ->with($this->equalTo(
                "SELECT userId, lastName, firstName, emailAddress AS email, " .
                "phone, birthDate, active, attributes " .
                "FROM user  WHERE firstName LIKE :firstName AND " .
                "lastName LIKE :lastName " .
                "LIMIT 100 OFFSET 0"))
            ->will($this->returnValue($pdo_statement));

        $object = new PdoModelUnitTest($security, $cache, $pdo);
        $query_result = $object->query($parameters);
        $this->assertCount(1, $query_result);
        $this->assertArrayHasKey("userId", $query_result[0]);
        $this->assertEquals("12345", $query_result[0]["userId"]);
    }

    /**
     * @covers \Cougar\Model\PdoModel::__construct
     * @covers \Cougar\Model\PdoModel::query
     *
     * @todo Until the cache supports grouped clearing, caching of queries has
     *       been disabled. Change the cache entries as necessary once it works.
     */
    public function testQueryWithLimitAndOffset() {
        $parameters = array(
            new QueryParameter("firstName", "John", "**"),
            new QueryParameter("lastName", "Doe", "**"),
            new QueryParameter("_limit", "100"),
            new QueryParameter("_offset", 500)
        );

        $security = new Security();

        $cache = $this->getMock("\\Cougar\\Cache\\Cache");
        $cache->expects($this->never())
            ->method("get");
        $cache->expects($this->never())
            ->method("set");

        $pdo_statement = $this->getMock("\\PDOStatement");
        $pdo_statement->expects($this->once())
            ->method("execute")
            ->with($this->equalTo(array(
                "firstName" => "%John%",
                "lastName" => "%Doe%")))
            ->will($this->returnValue(true));
        $pdo_statement->expects($this->at(1))
            ->method("fetchAll")
            ->will($this->returnValue(array(array(
                "userId" => "12345",
                "lastName" => "Doe",
                "firstName" => "John",
                "emailAddress" => "john.doe@example.com",
                "phone" => "800-555-1212",
                "active" => "1",
                "attributes" => json_encode(array("a" =>1, "b" => 2))))));

        $pdo = $this->getMock("\\PDO",
            array("prepare"),
            array("sqlite::memory:"));
        $pdo->expects($this->once())
            ->method("prepare")
            ->with($this->equalTo(
                "SELECT userId, lastName, firstName, emailAddress AS email, " .
                "phone, birthDate, active, attributes " .
                "FROM user  WHERE firstName LIKE :firstName AND " .
                "lastName LIKE :lastName " .
                "LIMIT 100 OFFSET 500"))
            ->will($this->returnValue($pdo_statement));

        $object = new PdoModelUnitTest($security, $cache, $pdo);
        $query_result = $object->query($parameters);
        $this->assertCount(1, $query_result);
        $this->assertArrayHasKey("userId", $query_result[0]);
        $this->assertEquals("12345", $query_result[0]["userId"]);
    }

    /**
     * @covers \Cougar\Model\PdoModel::__construct
     * @covers \Cougar\Model\PdoModel::query
     *
     * @todo Until the cache supports grouped clearing, caching of queries has
     *       been disabled. Change the cache entries as necessary once it works.
     */
    public function testQueryUnique() {
        $security = new Security();
        /*
        $cache = $this->getMock("\\Cougar\\Cache\\Cache");
        $cache->expects($this->once())
            ->method("get")
            ->with("unittest.model.query." .
                md5(serialize($parameters) . "array.__default__"))
            ->will($this->returnValue(false));
        $cache->expects($this->once())
            ->method("set")
            ->will($this->returnValue(false));
        */
        $cache = $this->getMock("\\Cougar\\Cache\\Cache");
        $cache->expects($this->never())
            ->method("get");
        $cache->expects($this->never())
            ->method("set");

        $pdo_statement = $this->getMock("\\PDOStatement");
        $pdo_statement->expects($this->once())
            ->method("execute")
            ->with()
            ->will($this->returnValue(true));
        $pdo_statement->expects($this->at(1))
            ->method("fetchAll")
            ->will($this->returnValue(array(array(
                "userId" => "12345",
                "lastName" => "Doe",
                "firstName" => "John",
                "emailAddress" => "john.doe@example.com",
                "phone" => "800-555-1212",
                "active" => "1",
                "attributes" => json_encode(array("a" =>1, "b" => 2))))));

        $pdo = $this->getMock("\\PDO",
            array("prepare"),
            array("sqlite::memory:"));
        $pdo->expects($this->once())
            ->method("prepare")
            ->with($this->equalTo(
                "SELECT DISTINCT userId, lastName, firstName, " .
                    "emailAddress AS email, phone, birthDate, active, " .
                    "attributes " .
                "FROM user  " .
                "LIMIT 10000 OFFSET 0"))
            ->will($this->returnValue($pdo_statement));

        $object = new PdoModelUnitTestQueryUnique($security, $cache, $pdo);
        $query_result = $object->query();
        $this->assertCount(1, $query_result);
        $this->assertArrayHasKey("userId", $query_result[0]);
        $this->assertEquals("12345", $query_result[0]["userId"]);
    }

    /**
     * @covers \Cougar\Model\PdoModel::__construct
     */
    public function testToArrayWithDefaultValues()
    {
        $security = new Security();
        
        $cache = $this->getMock("\\Cougar\\Cache\\Cache");
        
        $pdo = new PDO("sqlite::memory:");
        
        $object = new PdoModelUnitTest($security, $cache, $pdo);
        
        $this->assertEquals(array(
            "userId" => null,
            "lastName" => null,
            "firstName" => null,
            "email" => null,
            "phone" => null,
            "birthDate" => null,
            "active" => true,
            "attributes" => array(),
            "unboundProperty" => null), $object->__toArray());
    }

    /**
     * @covers \Cougar\Model\PdoModel::__construct
     * @expectedException \Cougar\Exceptions\BadRequestException
     */
    public function testSaveWithDefaultValues()
    {
        $security = new Security();
        
        $cache = $this->getMock("\\Cougar\\Cache\\Cache");
        
        $pdo = new PDO("sqlite::memory:");
        
        $object = new PdoModelUnitTest($security, $cache, $pdo);
        $object->save();
    }

    /**
     * @covers \Cougar\Model\PdoModel::__construct
     * @covers \Cougar\Model\PdoModel::endPersistence
     * @covers \Cougar\Model\WsModel::save
     * @expectedException \Cougar\Exceptions\Exception
     */
    public function testEndPersistenceWithSave()
    {
        $security = new Security();

        $cache = $this->getMock("\\Cougar\\Cache\\Cache");

        $pdo = new PDO("sqlite::memory:");

        $object = new PdoModelUnitTest($security, $cache, $pdo);
        $object->endPersistence();
        $object->save();
    }

    /**
     * @covers \Cougar\Model\PdoModel::__construct
     * @covers \Cougar\Model\PdoModel::endPersistence
     * @covers \Cougar\Model\WsModel::delete
     * @expectedException \Cougar\Exceptions\Exception
     */
    public function testEndPersistenceWithDelete()
    {
        $security = new Security();

        $cache = $this->getMock("\\Cougar\\Cache\\Cache");

        $pdo = new PDO("sqlite::memory:");

        $object = new PdoModelUnitTest($security, $cache, $pdo);
        $object->endPersistence();
        $object->delete();
    }

    /**
     * @covers \Cougar\Model\PdoModel::__construct
     * @covers \Cougar\Model\PdoModel::endPersistence
     * @covers \Cougar\Model\WsModel::query
     * @expectedException \Cougar\Exceptions\Exception
     */
    public function testEndPersistenceWithQuery()
    {
        $security = new Security();

        $cache = $this->getMock("\\Cougar\\Cache\\Cache");

        $pdo = new PDO("sqlite::memory:");

        $object = new PdoModelUnitTest($security, $cache, $pdo);
        $object->endPersistence();
        $object->query();
    }

    /**
     * @covers \Cougar\Model\PdoModel::__construct
     * @covers \Cougar\Model\PdoModel::save
     * @expectedException \Cougar\Exceptions\AccessDeniedException
     */
    public function testCreateSecurity()
    {
        $security = new Security();

        $cache = $this->getMock("\\Cougar\\Cache\\Cache");
        $cache->expects($this->never())
            ->method("get");
        $cache->expects($this->never())
            ->method("set");

        $pdo = $this->getMock("\\PDO",
            array("prepare"),
            array("sqlite::memory:"));
        $pdo->expects($this->never())
            ->method("prepare");

        $object = new PdoModelNoCreateUnitTest($security, $cache, $pdo);
        $object->id = "abc";
        $object->save();

        $this->fail("Expected exception was not thrown");
    }

    /**
     * @covers \Cougar\Model\PdoModel::__construct
     * @expectedException \Cougar\Exceptions\AccessDeniedException
     */
    public function testReadSecurity()
    {
        $security = new Security();

        $cache = $this->getMock("\\Cougar\\Cache\\Cache");
        $cache->expects($this->never())
            ->method("get");
        $cache->expects($this->never())
            ->method("set");

        $pdo = $this->getMock("\\PDO",
            array("prepare"),
            array("sqlite::memory:"));
        $pdo->expects($this->never())
            ->method("prepare");

        $object = new PdoModelNoReadUnitTest($security, $cache, $pdo,
            array("id" => "id"));

        $this->fail("Expected exception was not thrown");
    }

    /**
     * @covers \Cougar\Model\PdoModel::__construct
     * @covers \Cougar\Model\PdoModel::save
     * @expectedException \Cougar\Exceptions\AccessDeniedException
     */
    public function testUpdateSecurity()
    {
        $security = new Security();

        $cache = $this->getMock("\\Cougar\\Cache\\Cache");
        $cache->expects($this->once())
            ->method("get")
            ->will($this->returnValue(false));
        $cache->expects($this->once())
            ->method("set")
        ->will($this->returnValue(false));

        $pdo_statement = $this->getMock("\\PDOStatement");
        $pdo_statement->expects($this->once())
            ->method("execute")
            ->will($this->returnValue(true));
        $pdo_statement->expects($this->at(2))
            ->method("fetch")
            ->will($this->returnValue(array(
                "id" => "id")));
        $pdo_statement->expects($this->at(3))
            ->method("fetch")
            ->will($this->returnValue(false));

        $pdo = $this->getMock("\\PDO",
            array("prepare"),
            array("sqlite::memory:"));
        $pdo->expects($this->once())
            ->method("prepare")
            ->will($this->returnValue($pdo_statement));

        $object = new PdoModelNoUpdateUnitTest($security, $cache, $pdo,
            array("id" => "id"));
        $object->save();

        $this->fail("Expected exception was not thrown");
    }

    /**
     * @covers \Cougar\Model\PdoModel::__construct
     * @covers \Cougar\Model\PdoModel::delete
     * @expectedException \Cougar\Exceptions\AccessDeniedException
     */
    public function testDeleteSecurity()
    {
        $security = new Security();

        $cache = $this->getMock("\\Cougar\\Cache\\Cache");
        $cache->expects($this->once())
            ->method("get")
            ->will($this->returnValue(false));
        $cache->expects($this->once())
            ->method("set")
            ->will($this->returnValue(false));

        $pdo_statement = $this->getMock("\\PDOStatement");
        $pdo_statement->expects($this->once())
            ->method("execute")
            ->will($this->returnValue(true));
        $pdo_statement->expects($this->at(2))
            ->method("fetch")
            ->will($this->returnValue(array(
                "id" => "id")));
        $pdo_statement->expects($this->at(3))
            ->method("fetch")
            ->will($this->returnValue(false));

        $pdo = $this->getMock("\\PDO",
            array("prepare"),
            array("sqlite::memory:"));
        $pdo->expects($this->once())
            ->method("prepare")
            ->will($this->returnValue($pdo_statement));

        $object = new PdoModelNoUpdateUnitTest($security, $cache, $pdo,
            array("id" => "id"));
        $object->delete();

        $this->fail("Expected exception was not thrown");
    }

    /**
     * @covers \Cougar\Model\PdoModel::__construct
     * @covers \Cougar\Model\PdoModel::query
     * @expectedException \Cougar\Exceptions\AccessDeniedException
     */
    public function testQuerySecurity()
    {
        $security = new Security();

        $cache = $this->getMock("\\Cougar\\Cache\\Cache");
        $cache->expects($this->never())
            ->method("get");
        $cache->expects($this->never())
            ->method("set");

        $pdo = $this->getMock("\\PDO",
            array("prepare"),
            array("sqlite::memory:"));
        $pdo->expects($this->never())
            ->method("prepare");

        $object = new PdoModelNoQueryUnitTest($security, $cache, $pdo);
        $object->query();

        $this->fail("Expected exception was not thrown");
    }
}

require_once(__DIR__ . "/../../Cougar/Model/iArrayExportable.php");
require_once(__DIR__ . "/../../Cougar/Model/iStruct.php");
require_once(__DIR__ . "/../../Cougar/Model/iAnnotatedClass.php");
require_once(__DIR__ . "/../../Cougar/Model/tAnnotatedClass.php");
require_once(__DIR__ . "/../../Cougar/Model/iModel.php");
require_once(__DIR__ . "/../../Cougar/Model/tModel.php");
require_once(__DIR__ . "/../../Cougar/Model/iPersistentModel.php");
require_once(__DIR__ . "/../../Cougar/Model/tPdoModel.php");
require_once(__DIR__ . "/../../Cougar/Model/PdoModel.php");

/**
 * Example PdoModel extension
 * 
 * Note: Annotations have inconsistent white space on purpose to validate
 * parsing routines.
 * 
 * @Table user
 * @Allow CREATE READ UPDATE DELETE QUERY
 * @PrimaryKey userId
 * @CachePrefix unittest.model
 * @CacheTime    60
 */
class PdoModelUnitTest extends PdoModel
{
    /**
     * @ReadOnly
     * @var int User ID
     */
    public $userId;
    
    /**
     * @NotNull
     * @var string User's last name
     */
    public $lastName;
    
    /**
     * @NotNull
     * @var string User's first name
     */
    public $firstName;
    
    /**
     * @Column emailAddress
     * @Regex /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z0-9-]+$/i
     * @NotNull
     * @var string User's email address
     */
    public $email;
    
    /**
     * @var string User's phone number
     */
    public $phone;
    
    /**
     * @DateTimeFormat Date
     * @var DateTime User's birth date
     */
    public $birthDate;

    /**
     * @var bool Whether user is active
     */
    public $active = true;

    /**
     * @var array User attributes
     */
    public $attributes;

    /**
     * @Unbound
     * @var string Some unbound value
     */
    public $unboundProperty;
}

/**
 * @Allow QUERY
 * @QueryUnique
 */
class PdoModelUnitTestQueryUnique extends PdoModelUnitTest
{

}

/**
 * @Table user
 * @Allow QUERY
 * @PrimaryKey id
 */
class PdoModelNoReadUnitTest extends \Cougar\Model\PdoModel
{
    /**
     * @var int ID
     */
    public $id;
}

/**
 * @Table user
 * @Allow QUERY
 * @PrimaryKey id
 */
class PdoModelNoCreateUnitTest extends \Cougar\Model\PdoModel
{
    /**
     * @var int ID
     */
    public $id;
}

/**
 * @Table user
 * @Allow READ QUERY
 * @PrimaryKey id
 */
class PdoModelNoUpdateUnitTest extends \Cougar\Model\PdoModel
{
    /**
     * @var int ID
     */
    public $id;
}


/**
 * @Table user
 * @Allow READ
 * @PrimaryKey id
 */
class PdoModelNoQueryUnitTest extends \Cougar\Model\PdoModel
{
    /**
     * @var int ID
     */
    public $id;
}
?>
